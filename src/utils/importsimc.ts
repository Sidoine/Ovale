import { format } from "@wowts/string";
import { existsSync, mkdirSync, readFileSync, readdirSync, writeFileSync } from "fs";
import { Ovale } from "../Ovale";
import { eventDispatcher } from "@wowts/wow-mock";
import { OvaleEquipment } from "../Equipment";
import { OvaleSpellBook } from "../SpellBook";
import { OvaleStance } from "../Stance";
import { OvaleSimulationCraft, Annotation } from "../SimulationCraft";
import  { registerScripts } from "../scripts/index";
import { getSpellData, PowerType, SpellPowerData } from "./importspells";
import { ipairs } from "@wowts/lua";

let outputDirectory = "src/scripts";
const simcDirectory = process.argv[2];
const profilesDirectory = simcDirectory + '/profiles/PreRaids';
const SIMC_CLASS = [
    "deathknight",
    // "demonhunter",
    // "druid",
    // "hunter",
    // "mage",
    // "monk",
    // "paladin",
    // "priest",
    // "rogue",
    // "shaman",
    // "warlock",
    // "warrior"
];

function Canonicalize(s: string) {
    let token = "xXxUnDeRsCoReXxX";
    s = s.toLowerCase();
    s = s.replace(/[\s\-\_\(\)\{\}\[\]]/g, token);
    s = s.replace(/\./g, "");
    s = s.replace(/xXxUnDeRsCoReXxX/g, "_");
    s = s.replace("_+", "_");
    s = s.replace("^_", "");
    s = s.replace("_$", "");
    return s;
}

if (!existsSync(outputDirectory)) mkdirSync(outputDirectory);

for (const simcClass of SIMC_CLASS) {
    let output: string[] = []
    let fileName = outputDirectory + "/ovale_" + simcClass + ".ts";
    const file = readFileSync(fileName, { encoding: "utf8" });
    const lines = file.split("\n");
    let passthrough = true;
    for (const line of lines) {
        if (passthrough) {
            output.push(line);
            if (line.indexOf("THE REST OF THIS FILE IS AUTOMATICALLY GENERATED") >= 0) {
                output.push("// ANY CHANGES MADE BELOW THIS POINT WILL BE LOST.\n");
                passthrough = false;
            }
        } else {
            break;
        }
    }
    writeFileSync(fileName, output.join("\n"));
}

let files: string[] = []
{
    let dir = readdirSync(profilesDirectory);
    for (const name of dir) {
        files.push(name);
    }
    files.sort();
}

const spellData = getSpellData(simcDirectory);

const spellsByClass = new Map<string, number[]>();
const talentsByClass = new Map<string, number[]>();
const itemsByClass = new Map<string, number[]>();

for (const filename of files) {
    if (filename !== 'PR_Death_Knight_Frost.simc') continue;
    if (!filename.startsWith("generate")) {
        let output: string[] = []
        let inputName = profilesDirectory + "/" + filename;
        let simc = readFileSync(inputName, { encoding: "utf8" });
        if (simc.indexOf("optimal_raid=") < 0) {
            let source: string, className: string, specialization: string;
            for (const line of simc.match(/[^\r\n]+/g)) {
                if (!source) {
                    if (line.substring(0, 3) == "### ") {
                        source = line.substring(4);
                    }
                }
                if (!className) {
                    for (const simcClass of SIMC_CLASS) {
                        let length = simcClass.length;
                        if (line.substring(0, length + 1) == simcClass + "=") {
                            className = simcClass.toUpperCase();
                        }
                    }
                }
                if (!specialization) {
                    if (line.substring(0, 5) == "spec=") {
                        specialization = line.substring(5);
                    }
                }
                if (className && specialization) {
                    break;
                }
            }
            
            console.log(filename);
            Ovale.playerGUID = "player";
            Ovale.playerClass = className;
            eventDispatcher.DispatchEvent("ADDON_LOADED", "Ovale");
            OvaleEquipment.UpdateEquippedItems();
            OvaleSpellBook.Update();
            OvaleStance.UpdateStances();
            registerScripts();

            const annotation: Annotation = {
                dictionary: Object.assign({}, spellData.identifiers)
            };
            let profile = OvaleSimulationCraft.ParseProfile(simc, annotation);
            let profileName = profile.annotation.name.substring(1, profile.annotation.name.length - 2);
            let name: string, desc: string;
            if (source) {
                desc = format("%s: %s", source, profileName);
            } else {
                desc = profileName;
            }
            name = Canonicalize(desc);
            output.push("");
            output.push("{");
            output.push(format('	const name = "sc_%s"', name));
            output.push(format('	const desc = "[8.0] Simulationcraft: %s"', desc));
            output.push("	const code = `");
            output.push(OvaleSimulationCraft.Emit(profile, true));
            output.push("`");
            output.push(format('	OvaleScripts.RegisterScript("%s", "%s", name, desc, code, "%s")', profile.annotation.class, profile.annotation.specialization, "script"));
            output.push("}");
            output.push("");
            let outputFileName = "ovale_" + className.toLowerCase() + ".ts";
            console.log("Appending to " + outputFileName + ": " + name);
            let outputName = outputDirectory + "/" + outputFileName;
            writeFileSync(outputName, output.join("\n"), { flag: 'a' });

            let classSpells = spellsByClass.get(className);
            if (!classSpells) {
                classSpells = [];
                spellsByClass.set(className, classSpells);
            }
            let classTalents = talentsByClass.get(className);
            if (!classTalents) {
                classTalents = [];
                talentsByClass.set(className, classTalents);
            }
            let classItems = itemsByClass.get(className);
            if (!classItems) {
                classItems = [];
                itemsByClass.set(className, classItems);
            }
            for (const [, symbol] of ipairs(profile.annotation.symbolList)) {
                const id = spellData.identifiers[symbol];
                if (symbol.match(/_talent$/)) {
                    if (id && classTalents.indexOf(id) < 0) {
                        classTalents.push(id);
                    }
                } else if (symbol.match(/_item$/)) {
                    if (id && classItems.indexOf(id) < 0) {
                        classItems.push(id);
                    }
                } else {
                    if (id && classSpells.indexOf(id) < 0) {
                        classSpells.push(id)
                    }
                }
            }
        }
    }
}

function getPowerName(power: PowerType) {
    switch (power) {
        case PowerType.POWER_ASTRAL_POWER:
            return "astral_power";
        case PowerType.POWER_BURNING_EMBER:
            return "burning_ember";
        case PowerType.POWER_CHI:
            return "chi";
        case PowerType.POWER_COMBO_POINT:
            return "combo_points";
        case PowerType.POWER_DEMONIC_FURY:
            return "demonic_fury";
        case PowerType.POWER_ENERGY:
            return "energy";
        case PowerType.POWER_FOCUS:
            return "focus";
        case PowerType.POWER_FURY:
            return "fury";
        case PowerType.POWER_HEALTH:
            return "health";
        case PowerType.POWER_HOLY_POWER:
            return "holy_power";
        case PowerType.POWER_INSANITY:
            return "insanity";
        case PowerType.POWER_MAELSTROM:
            return "maelstrom";
        case PowerType.POWER_MANA:
            return "mana";
        case PowerType.POWER_PAIN:
            return "pain";
        case PowerType.POWER_RAGE:
            return "rage";
        case PowerType.POWER_RUNE:
            return "rune";
        case PowerType.POWER_RUNIC_POWER:
            return "runic_power";
        case PowerType.POWER_SOUL_SHARDS:
            return "soul_shards";
        default:
            return undefined;
    }
}

function getPowerValue(powerData: SpellPowerData) {
    let divisor = 1;
    switch (powerData.power_type) {
        case PowerType.POWER_MANA:
            divisor = 100;
            break;
        case PowerType.POWER_RAGE:
        case PowerType.POWER_RUNIC_POWER:
        case PowerType.POWER_BURNING_EMBER:
        case PowerType.POWER_ASTRAL_POWER:
        case PowerType.POWER_PAIN:
        case PowerType.POWER_SOUL_SHARDS:
            divisor = 10;
            break;
        //case PowerType.POWER_DEMONIC_FURY:
          // return percentage ? 0.1 : 1.0;  
    }
    return powerData.cost / divisor;
}

for (const [className, spellIds] of spellsByClass) {
    let output = `import { OvaleScripts } from "../Scripts";

    export function register() {
        let name = "ovale_deathknight_spells";
        let desc = "[8.0] Ovale: Death Knight spells";
        let code = \`
`;        
    for (const spellId of spellIds) {
        const spell = spellData.spellDataById.get(spellId);
        output += `Define(${spell.identifier} ${spellId})\n`;
        output += `SpellInfo(${spell.identifier}`;
        if (spell.spellPowers) {
            for (const power of spell.spellPowers) {
                const powerName = getPowerName(power.power_type);
                if (power.cost) {
                    output += ` ${powerName}=${getPowerValue(power)}`
                }
            }
        }
        if (spell.cooldown) {
            output += ` cd=${spell.cooldown / 1000}`;
        }
        output += `)\n`;
        if (spell.spellEffects) {
            for (const effect of spell.spellEffects) {
                if (effect.trigger_spell_id) {
                    const triggerSpell = spellData.spellDataById.get(effect.trigger_spell_id);
                    if (triggerSpell === undefined) {
                        console.log(`Can't find spell ${effect.trigger_spell_id}`);
                        continue;
                    }
                    if (effect.targeting_1 > 1) {
                        output += `  SpellAddTargetDebuff(${spell.identifier} ${triggerSpell.identifier})\n`;
                    } else {
                        output += `  SpellAddBuff(${spell.identifier} ${triggerSpell.identifier})\n`;
                    }
                }
            }
        }
    }

    const talentIds = talentsByClass.get(className);
    if (talentIds) {
        for (const talentId of talentIds) {
            const talent = spellData.talentsById.get(talentId);
            output += `Define(${talent.identifier} ${talentId})\n`;
        }
    }

    const itemIds = itemsByClass.get(className);
    if (itemIds) {
        for (const itemId of itemIds) {
            const item = spellData.itemsById.get(itemId);
            output += `Define(${item.identifier} ${itemId})\n`;
        }
    }

    output+=`    \`;
        OvaleScripts.RegisterScript("DEATHKNIGHT", undefined, name, desc, code, "include");
    }
    `;

    writeFileSync(outputDirectory + "/ovale_" + className + "_spells.ts", output, { encoding: 'utf8'});
}